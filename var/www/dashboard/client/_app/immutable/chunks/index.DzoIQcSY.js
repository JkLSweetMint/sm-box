var f=Object.defineProperty;var m=(c,t,s)=>t in c?f(c,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):c[t]=s;var r=(c,t,s)=>m(c,typeof t!="symbol"?t+"":t,s);class h{constructor(t){r(this,"name");r(this,"type");r(this,"default");r(this,"fields");this.name=t.name,this.type=t.type??"string",this.fields=t.fields,t.default&&(this.default=this.Parse(t.default))}Field(t){if(t=="")return this;if(this.fields){if(t.includes(".")){const[s,i]=t.split(".",1),e=this.fields.find(n=>n.name==s);return e?e.Field(i):void 0}return this.fields.find(s=>s.name==t)}}Parse(t){switch(this.type){case"string":return`${t}`;case"number":const s=Number(t);return Number.isNaN(s)?0:s;case"boolean":return t=="y"||t=="Y"||t=="yes"||t=="Yes"||t=="t"||t=="T"||t=="true"||t=="True"||t=="1"||t==1||t==!0;case"object":let i={};return typeof t!="object"||this.fields&&this.fields.forEach(e=>i[e.name]=e.Parse(t[e.name])),i;case"date":switch(typeof t){case"string":case"number":return new Date(t);case"object":const e=new Date(t);return e.toString()!="Invalid Date"?e:new Date(0);default:return new Date(0)}}}}class l{constructor(t){r(this,"_name");r(this,"_key");r(this,"_fields");r(this,"_onChange");r(this,"_data");this._name=t.name,this._key=t.key??t.name.toLowerCase(),this._fields=t.fields,this._data={},this._onChange=t.onChange}get _dataName(){return`[${this._name}]:`}_FindField(t){if(t.includes(".")){const[s,i]=t.split(".",1),e=this._fields.find(n=>n.name==s);return e?e.Field(i):void 0}return this._fields.find(s=>s.name==t)}_NestedProperty(t,s,i,e=0,n="get"){if(t.length<1||e>=t.length)throw new Error("empty key");const o=t[0];var a=s[o];if(e==t.length-1)switch(n){case"get":return a;case"set":return a=i}if(typeof a!="object")throw new Error(`Incorrect path to property: "${t.slice(0,e+1).join(".")}"`);return this._NestedProperty(t,a,i,e+1,n)}OnChange(t){this._onChange=t}GetProperty(t){if(t=t.trim(),t=="")return;const s=this._FindField(t);if(s)return t.includes(".")?s.Parse(this._NestedProperty(t.split("."),this._data,void 0,0,"get")):s.Parse(this._data[t])}SetProperty(t,s){if(t=t.trim(),t=="")throw new Error("Empty key");const i=this._FindField(t);if(!i)throw new Error(`Unknown field: "${t}"`);const e=this.GetProperty(t);let n=i.Parse(s);i.default&&(n=n||i.default);const o=i.Parse(n);return t.includes(".")?this._NestedProperty(t.split("."),this._data,i.Parse(n),0,"set"):this._data[t]=i.Parse(n),this._onChange&&this._onChange({field:i,oldValue:e,newValue:o}),this}Clear(){localStorage.removeItem(this._key),this._data={}}Save(){localStorage.setItem(this._key,btoa(this._dataName+JSON.stringify(this._data)))}Load(){const t=localStorage.getItem(this._key);try{const s=t?JSON.parse(atob(t).replace(this._dataName,"")):{};this._data=Object.fromEntries(this._fields.map(i=>{let e=s[i.name],n=e?i.Parse(e):void 0;return i.default&&(n=n||i.default),this._onChange&&this._onChange({field:i,oldValue:void 0,newValue:n}),[i.name,n]}))}catch{throw new Error("Bad decode")}return this}toString(){return this._dataName+JSON.stringify(this._data)}Validate(t){let s={};const i=function(o,a){s[o]={status:"fail",description:a}};for(var e in t){if(e=e.trim(),e=="")continue;var n=t[e];const o=this._FindField(e);if(!o){i(e,`Unknown field: "${e}"`);continue}const a=e.includes(".")?o.Parse(this._NestedProperty(e.split("."),this._data,void 0,0,"get")):o.Parse(this._data[e]);if(n.required&&a==null||a==null||a==""){i(e,"Value is required");continue}if(n.min&&n.min>=0)switch(o.type){case"string":if(a.length<n.min){i(e,`Minimum acceptable length is ${n.min}`);continue}break;case"number":if(a<n.min){i(e,`Minimum acceptable value is ${n.min}`);continue}break}if(n.max&&n.max>=0)switch(o.type){case"string":if(a.length>n.max){i(e,`Maximum acceptable length is ${n.min}`);continue}break;case"number":if(a>n.max){i(e,`Maximum acceptable value is ${n.min}`);continue}break}if(n.blacklist&&n.blacklist.length>0&&n.blacklist.includes(a)){i(e,`Value "${a}" is not allowed`);continue}if(n.whitelist&&n.whitelist.length>0&&!n.whitelist.includes(a)){i(e,`Value "${a}" is not allowed. Allowed values are specified via whitelist: ${JSON.stringify(n.whitelist)}`);continue}}return s}toBase(){return this}toObject(){return JSON.parse(JSON.stringify(this._data))}fromObject(t){const s=Object.entries(t);return this._data=Object.fromEntries(this._fields.map(i=>{const e=s.find(n=>n[0]==i.name)??[i.name,null];return this._onChange&&this._onChange({field:i,oldValue:void 0,newValue:e[1]}),[i.name,i.default?e[1]||i.default:e[1]]})),this}Copy(){let t=new l({name:this._name,fields:this._fields,key:this._key,onChange:this._onChange});return t._data=JSON.parse(JSON.stringify(this._data)),t}}const d=class d extends l{static GetInstance(){return this._instance||(this._instance=new d),this._instance}constructor(t){super({name:"Settings",fields:[new h({name:"theme",type:"string"}),new h({name:"sidebarImage",type:"string"}),new h({name:"direction",type:"string",default:"ltr"}),new h({name:"navbarApperance",type:"string",default:"sticky"}),new h({name:"navbarPosition",type:"string",default:"attached"}),new h({name:"componentStyle",type:"string",default:"default"}),new h({name:"expandNavbar",type:"boolean",default:!1})],onChange:t==null?void 0:t.onChange})}ValidateEntity(){return this.Validate(d._rules)}Copy(){let t=new d({onChange:this._onChange});return t._data=JSON.parse(JSON.stringify(this._data)),t}};r(d,"_rules",{direction:{whitelist:["ltr","rtl"],required:!0},navbarApperance:{whitelist:["sticky","static","hidden"],required:!0},navbarPosition:{whitelist:["attached","separated"],required:!0},componentStyle:{whitelist:["default","bordered"],required:!0}}),r(d,"_instance");let u=d;export{u as S};
